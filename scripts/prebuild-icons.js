const fs = require('fs');
const path = require('path');
const https = require('https');

// Import the slugs from our skills file
const skillsPath = path.join(__dirname, '../src/constants/skills.ts');
const skillsContent = fs.readFileSync(skillsPath, 'utf8');

// Extract slugs array from the TypeScript file
const slugsMatch = skillsContent.match(/export const slugs = \[([\s\S]*?)\];/);
if (!slugsMatch) {
  console.error('Could not find slugs array in skills.ts');
  process.exit(1);
}

const slugsText = slugsMatch[1];
const slugs = slugsText
  .split(',')
  .map(line => line.trim())
  .filter(line => line.startsWith("'") || line.startsWith('"'))
  .map(line => line.slice(1, -1)); // Remove quotes

console.log(`üîç Found ${slugs.length} icon slugs to pre-fetch`);

// Simple Icons API base URL
const SIMPLE_ICONS_API = 'https://cdn.jsdelivr.net/npm/simple-icons@v11';

async function fetchIcon(slug) {
  return new Promise((resolve, reject) => {
    const url = `${SIMPLE_ICONS_API}/icons/${slug}.svg`;
    
    https.get(url, (res) => {
      if (res.statusCode !== 200) {
        console.warn(`‚ö†Ô∏è  Failed to fetch ${slug}: ${res.statusCode}`);
        resolve(null);
        return;
      }
      
      let data = '';
      res.on('data', chunk => data += chunk);
      res.on('end', () => {
        try {
          // Extract the SVG content and create a simple icon object
          const svgMatch = data.match(/<svg[^>]*>(.*?)<\/svg>/s);
          if (svgMatch) {
            const iconData = {
              title: slug.charAt(0).toUpperCase() + slug.slice(1),
              slug: slug,
              svg: data,
              path: svgMatch[1].match(/d="([^"]+)"/)?.[1] || '',
              source: url
            };
            console.log(`‚úÖ Fetched ${slug}`);
            resolve(iconData);
          } else {
            console.warn(`‚ö†Ô∏è  Invalid SVG for ${slug}`);
            resolve(null);
          }
        } catch (error) {
          console.warn(`‚ö†Ô∏è  Error parsing ${slug}:`, error.message);
          resolve(null);
        }
      });
    }).on('error', (error) => {
      console.warn(`‚ö†Ô∏è  Network error for ${slug}:`, error.message);
      resolve(null);
    });
  });
}

async function prebuildIcons() {
  console.log('üöÄ Starting icon pre-fetch...');
  
  const icons = {};
  const batchSize = 5; // Limit concurrent requests
  
  for (let i = 0; i < slugs.length; i += batchSize) {
    const batch = slugs.slice(i, i + batchSize);
    console.log(`üì¶ Processing batch ${Math.floor(i/batchSize) + 1}/${Math.ceil(slugs.length/batchSize)}`);
    
    const batchResults = await Promise.all(
      batch.map(slug => fetchIcon(slug))
    );
    
    batchResults.forEach((icon, index) => {
      if (icon) {
        icons[batch[index]] = icon;
      }
    });
    
    // Small delay to be nice to the CDN
    if (i + batchSize < slugs.length) {
      await new Promise(resolve => setTimeout(resolve, 100));
    }
  }
  
  // Create the output directory
  const outputDir = path.join(__dirname, '../src/data');
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }
  
  // Write the pre-fetched icons
  const outputPath = path.join(outputDir, 'prebuilt-icons.json');
  const output = {
    generatedAt: new Date().toISOString(),
    totalIcons: Object.keys(icons).length,
    icons: icons
  };
  
  fs.writeFileSync(outputPath, JSON.stringify(output, null, 2));
  
  console.log(`üéâ Successfully pre-fetched ${Object.keys(icons).length}/${slugs.length} icons`);
  console.log(`üìÅ Saved to: ${outputPath}`);
  
  // Also create a TypeScript type definition
  const typesContent = `// Auto-generated by prebuild-icons.js
export interface PrebuiltIcon {
  title: string;
  slug: string;
  svg: string;
  path: string;
  source: string;
}

export interface PrebuiltIconsData {
  generatedAt: string;
  totalIcons: number;
  icons: Record<string, PrebuiltIcon>;
}
`;
  
  fs.writeFileSync(path.join(outputDir, 'prebuilt-icons.types.ts'), typesContent);
  console.log('üìù Generated TypeScript types');
}

// Run the prebuild
prebuildIcons().catch(error => {
  console.error('‚ùå Prebuild failed:', error);
  process.exit(1);
});
